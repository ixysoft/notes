/**
* 解题思路:
* 解题的关键点在于字符串状态转化的这个点,从这个点向两边延伸.总情况数总是倾向于最小的一遍.
* 比如:00011  这个字符串的转折点在0到1之间,从这个转折点向两边延伸,因为右边比较少,所以只可能是两种情况(比较少的连续数字的长度).
* 有了这个思路,这道题目也就简单了,我这里的思路是记录下0,1字符连续的个数.每次遇到转折点(从一个字符转到另一个字符),我们进行一次统计.
* 这里统计的并不是当前遍历到的转折点与其前面连续数字的情况数,而是计算上一个连续数字与上上个连续数字的情况数.
* 比如: 0001111000 第一个转折点的时候 0的计数为3,虽然已经遍历到了1,但是此时的1还没有计数.直到下一个转折点0,此时新一轮的0也还没有计数,
* 但是上一轮的一对数据已经产生,我们在0的计数和1的计数中选取一个最小值,加入总计数.
* 这里有两种特殊情况需要考虑,一种是第一个转折点,很容易知道,在第一个转折点的时候,另外一个还没有计数,所以0和1的计数最小值依然还是0,对结果无影响.
* 第二种特殊情况是遍历结束后,因为在遍历到结尾的\0时,循环结束,并不会处理当前已经计数的数字,所以在返回结果时,加上上一对数据.
*/

#include<stdio.h>

#define min(a,b) ((a)>(b)?(b):(a))

int subcount(char *str){
    int count[2] = {0}; //初始化数组记录两个字符的计数
    int i;
    int sum = 0;    //总数目
    for(i = count[str[0]&0x01] = 1; str[i] != '\0'; i++){
        char idx = str[i] & 0x01;   //下标
        if(str[i-1] == str[i]) count[idx]++;    //字符相同则
        else{   //出现不相同元素
            sum += min(count[0],count[1]);
            count[idx] = 1; //重新设置count值
        }
    }

    return sum+min(count[0],count[1]);
}

int main(){
    char str[256];
    while(~scanf("%s",str)){
        printf("%d\n",subcount(str));
    }
}