# programiz.com中的思路  
**红黑树的基本属性:**  
1. 每个节点都有配色,非黑即红
2. 根节点为黑色
3. 叶子结点(NIL)为黑色
4. 如果一个红色的节点存在孩子,则孩子总是黑色
5. 从根节点到每个叶子节点的简单路径上总存在相同数目黑节点

**每个节点存在下面的几个属性:**  
1. color
2. key
3. leftChild
4. rightChild
5. parent(root节点为parent为NULL)  

**红黑树如果维持自平衡?:**  
红黑树中节点中的颜色概念是为了平衡树结构而设定的.  
从根节点到叶子节点的每条简单路径中的黑节点个数相同保证了任意一条路径不会超过另一条路径长度的1倍

## 红黑树的操作:  
**有很多可以在红黑树上执行的操作:**  
### 红黑树中子树的旋转  
#### 左旋
算法:  
1. 假设树的初始状态为:  
        p
        |
       [x]
       / \
      α  [y]
         / \
        β   γ
2. 如果`y`存在左子树,将x设定为y左子树的父节点
        p
        |
       [x]
       / \
      α   β  [y]
               \
                γ
3. 如果`x`的父节点为`NULL`,将`y`设为树的根节点
4. 否则如果`x`为`p`的左节点,使得`y`成为`p`的左节点
5. 否则将`y`设定为`p`的右节点
            p
            |
    [x]    [y]
    / \      \
   α   β      γ
6. 将`y`设定为`x`的父节点

#### 右旋
1. 初始结构为:  
        p
        |
       [y]
       / \
     [x]  α
     / \
    γ   β
2. 如果`x`存在右子树,将`y`设定为`x`右子树的父节点
            p
            |
           [y]
           / \
    [x]   β   α
    /
   γ
3. 如果`y`父节点为`NULL`,将`x`设定为树的根节点
4. 否则如果`y`为`p`的右孩子,将`x`设为`p`的右孩子
5. 否则将`x`设为`p`的左孩子
        p
        |
       [x]  [y]
       /    / \
      γ    β   α
6. 将`x`设为`y`的父节点  

#### 右左,左右旋转(RL,LR)
**在LR旋转中,我们首先进行左旋,之后执行右旋**  
1. 在`x-y`上执行左旋  
         p               p
         |               |
        [z]             [z]
        / \             / \
      [x]  δ    -->    [y] δ
      / \              / \
     α  [y]          [x]  γ
        / \          / \
       β   γ        α   β
2. 在`y-z`上执行右旋
     p                  p
     |                  |
    [z]                [y]
    / \                /  \
   [y] δ    -->      [x]  [z]
   / \               / \  / \
 [x]  γ             α   β γ  δ
 / \
α   β

**右左旋转与左右旋转相反:**
先执行右旋,在再执行左旋.  

**向红黑树中插入一个节点:**  
被插入的节点总是被设定为红色,在插入新节点后,如果红黑树的性质被破坏的话,我们需要做下面两个操作:  
1. 重新上色
2. 旋转

### 插入节点算法  
1. 将`y`设为`nil`,`x`设为树的根节点
2. 判断树是否为空(`x`==`nil`),如果是空树,将插入节点设为树的根节点
3. 如果不是,重复下面步奏,直到节点为`nil`:  
      a. 比较`newKey`与`rootKey`  
      b. 如果`newKey`>`rootKey`,说明结果可能在右边,遍历右子树  
      c. 否则遍历左子树  
4. 将叶子节点的父节点作为`newNode`的右节点
5. 如果`leafKey`>`newKey`,将`newNode`设为`rightChild`.
6. 否则,将`newNode`设为`leftChild`
7. 将newNode的左右子节点设为NULL
8. 将newNode设为Red
9. 调用插入修复函数,是的红黑树保持其基本性质