# 红黑树
**红黑树性质：**  
1. 节点是红色或者黑色
2. 根节点为黑色
3. 叶子节点为黑色
4. 红色节点的子节点为黑色
5. 任何一条根节点到叶子节点路径上的黑色节点数相同  
**节点的插入：**  
```
新节点默认设置为红色
如果树为空，则插入一个根节点，颜色设置为黑色。   
如果当前插入节点的父节点为黑色，不进行调整
如果当前插入节点的父节点为红色，根据红黑树的性质可知必定存在祖父节点。判断叔父节点是否为红色
如果叔父节点为红色，则反转叔父，父，祖父节点的颜色，此事祖父节点为红色，将祖父节点视作新插入的节点进行判断。直到整体满足红黑树的性质  
如果叔父节点为黑色，反转父，祖父节点的颜色。
判断当前节点与祖父节点的关系：
1. 左子节点的左子节点
对祖父节点进行右旋，我们记为（LL）
2. 右子节点的右子节点
对祖父节点进行左旋,我们记为(RR)
3. 左子节点的右子节点
对当前节点的父节点进行左旋，对祖父节点进行右旋操作。这个过程我们记为（LR）
4. 右子节点的左子节点
对当前节点的父节点进行右旋，对祖父节点进行左旋操作。这个过程我们记为（RL）
进过此四步后，树整体符合红黑树的性质
```
**节点删除:**  
```
假设需要删除节点的前驱节点或后继节点为U,具体选择前驱或者后继看情况.  
前驱节点的左孩子为V或后继节点的右孩子为V,这里根据上一步确定.  
我们把U称为待删除节点.(在BST中我们一般不直接删除某个节点,而是删除其前驱或后继节点,然后将前驱或者后继节点的值传递给要删除的节点)
待删除节点U的兄弟节点我们称之为S,S的左孩子我们称之为S_l,右孩子我们称为S_r.
U的父节点我们称为P.  
接下来的情况中,我们分析前驱节点存在的情况.后继节点存在的情况同理.  
不同的情况分析:
1. 当前节点为根节点且没有后代
直接删除就ok了.  
2. U为红节点.
此时,替死鬼节点U是红接地,我们可以确定P和V都是黑色的节点,由红黑树的性质可以,删除红节点不会破坏红黑树的性质,所以我们可以节点U删除,并把V提到U的位置.  
3. U为黑节点.
此时删除该节点黑导致红黑树失衡.U一侧子树少了一层.
我们分情况讨论:
(1) S为红节点
此时我们可以确定P和S_l,S_r都是黑节点.
我们将右子树绕P左旋,并将S反转为黑色.此时以S为根的子树左右两侧重新平衡.
(2) S为黑节点
这里的情况比较复杂......
我们继续分情况讨论:
a. S至少存在一个红色的子节点.
ai. RR.
    此时我们将S_r设为黑色,并以P节点左旋.
aii. RL
    此时我们先以绕S节点,将S_l右旋成RR的情况,再进行左旋
b. S没有红色的子节点....
此时S也没有红节点可借,此时我们需要讨论
我们将S设置为红色.此时以P为根的子树少了一层.
bi. P为黑节点
此时我们需要重新调整以P为子树的上级树结构的平衡.
这里我之前有点懵逼,现在突然想到,此时相当于P节点变成了之前的V节点,可以继续套用上面的分析操作,直到将树调整到平衡的状态**********
bii. P为红节点
我们可以将P设置为黑节点,此时以P为根的子树高度补齐.
```
