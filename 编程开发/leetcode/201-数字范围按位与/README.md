**题目:**
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。  
**示例 1: **
```
输入: [5,7]
输出: 4
```
**示例 2:**
```
输入: [0,1]
输出: 0
```

很显然,这个题目用爆破一定会超时.......  
嗯,我还试了一下,果然超时了,就算优化了退出条件依然超时.  
这个题目我们应该从二进制的角度去思考:  
从左边开始观察二进制,只有代表范围边界数字的二进制位相同的地方,其二进制位才不会变化.其余地方,不论如何,二进制位必定改变.  
e.g.
观察二进制数
00111010    a
00110010    b
0011        相同的前缀.
后面的四位,首先看第一个不相同的位置,a&b在该位在一开始的情况下必定为0.  
我们继续观察,其后的位置,必定存在一个从0111编程1000的过程,1000这个数的后三个二进制位与其他的二进制与运算必定为0.  
所以边界数字的公共前缀即为我们需要的结果.  

