#include<stdio.h>

//模拟位运算的方式
int getSingle(int arr[],int size){
    int ones = 0, twos = 0; //出现1次,出现2次的二进制位
    int threes; //出现三次的二进制位
    int i;
    for(i = 0; i < size; i++){
        /**
         *  这里的ones代表以往结果中出现一次的二进制位结果.
         *  可能第一次会让人迷茫,其实第一次也是一样的,ones为0,
         *  表示之前没有出现过一次的元素.
         *  我们利用ones & 当前遍历到的元素即可得到出现过两次的元素.
         *  原因:我们知道ones各个二进制位表示出现过1次的二进制位,那么在
         *  之前出现过一次,在当前的元素中依然存在的,是不是就出现了两次呢.  
         *  twos前面的或也很好理解,之前出现过两次的元素不一定在当前元素中
         *  存在,ones是之前出现过一次的,ones&arr[i]是之前出现过一次,
         *  当前又出现了一次的,所以属于新的出现两次的元素.
         **/
        twos |= ones & arr[i];
        /**
         *  从异或运算的性质可知,两二进制位相同为0,不同为1.
         *  所以之前出现过一次的(ones中二进制位出现的1),当前元素不存在,
         *  或者之前元素(ones)没出现过,当前元素出现的二进制位,我们都看成新的
         *  出现一次的元素.
         **/
        ones ^= arr[i];
        /**
         * ones表示出现过一次的二进制位,twos表示出现过两次的二进制位,
         * 如果一个二进制位同时被标记为出现1次和出现两次,
         * 说明这个二进制位出现了三次.这里体现了twos放在ones前面的效果.
         * 由异或运算的性质可知,同一个数字连续异或另一个数字两次的结果依然是当前数字
         * e.g.
         *  12^13^13 = 12
         * twos中的二进制位表示其至少出现两次,
         * ones中的二进制位表示其出现过奇数次.
         * 同时满足该两件的最小整数就是3.
         * 自然而然,我们需要把同时满足条件的二进制位归0,自然而然的,
         * 我们就用到了取反操作.把原来是0的二进制位变成1,是1的地方变成0
         **/
        threes = ones & twos;
        ones &= ~threes;
        twos &= ~threes;
    }
    //遍历完整个数列,ones即是我们需要的结果
    return ones;
}

//统计二进制位的方式
int getSingle2(int arr[],int size){
    int i,j;
    int one = 0;    //唯一的数
    for(i = 0; i < 32; i++){    //int类型为32位
        int count = 0;  //当前位置二进制位上1出现的次数
        int mask = 1 << i;  //位掩码
        for(j = 0; j < size; j++){
            if((arr[j] & mask) > 0){  //当前遍历的数字对应二进制位上为1
                count++;
            }
        }
        if(count%3 == 1){   //当前二进制位出现次数不为3的倍数,其属于只出现1次的数字
            one|=mask;
        }

    }
    return one;
}

int main(){
    int arr[] = {
        1,2,1,1,2,3,3,4,2
    };
    int size = sizeof(arr)/sizeof(arr[0]);
    printf("模拟法:%d\n",getSingle(arr,size));

    printf("计数法:%d\n",getSingle2(arr,size));
    return 0;
}
