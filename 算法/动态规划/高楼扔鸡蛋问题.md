# 高楼扔鸡蛋
**题目**  
题设我们手里有K个鸡蛋，在我们面前有一栋N层高的楼，而我们手里的鸡蛋是加强蛋，并没有那么易碎。试求出在最坏的情况下至少需要扔多少次鸡蛋才能确定在某一层之后会碎。  
虽然题目有点扯蛋的意味，但是作为一个拥有端正态度的孩子，就是是扯蛋，我也应该好好的研究研究。  
**思考**
我们知道如果鸡蛋不限量，我们很容易就能想到用二分法丢鸡蛋，很容易就能确定在哪一层鸡蛋开始会碎。但是在我们没有足够多鸡蛋的情况下，我们就不太可能这么奢侈了，比如有15层楼，但是只有两个鸡蛋，假设在第9层开始鸡蛋会碎，第一次，我们在（15/2 = 7）第7层扔，没有碎，接下来我们在（(8+15)/2 = 11）第11层扔鸡蛋没了也没测出来，所以当我们还剩一个鸡蛋的时候，为了测出蛋碎点，我们就必须用遍历的方式。  
这里我们知道：  
1. 当没有鸡蛋的时候，需要扔0次能确定在某一层会碎。  
2. 当有一个鸡蛋的时候，最坏的情况下，需要遍历n层楼才能确定蛋碎点  
上面两种特殊情况说完了之后，我们再讨论一般情况。  
假设现在在第i层楼，现在有两种可能：  
1. 蛋碎了，现在有k-1个蛋，我们可以确定蛋碎点在1~i-1之间  
2. 蛋没碎，现在有k个蛋，我们可以确定蛋碎点在i+1到n之间  
这两种情况里面，我们应该选择到该层次数较大的那一个（最差的情况），而且还应该需要+1，因为需要多测试一次才能确定是否处于临界位置。  

好了讨论完一般情况，我们可以写出最差情况下最少需要验证次数的表达式:  
```
def count(k,n):
    if k == 0:
        return 0
    if k == 1:
        return n

    res = n
    for i = 1 to n: # 遍历每一层的最差最少次数
        max_res = max(count(k-1,i-1),count(k,n-i))+1 # 当前楼层最差的情况下需要的次数
        res = min(res,max_res) # 到当前楼层位置取较小的那个
    return res
```
但是我们很容易看一看到，在上面的函数中，count方法被重复调用了很多次，而且很多调用是没有必要的，我们知道count(k,n)中调用了count(k-1,i-1),count(k,n-i)这两个狮子，而这两种情况都是在count(k,n)之前执行的，count(k,n)的值并不会影响到其他两个式子的值。这个时候，我们就可以把这两个不会再后面改变的值缓存起来。这个时候我们可以一个二维数组缓存。  
```
dim DP[1000][1000]

def count(k,n):
    if k == 0:
        return 0
    if k == 1:
        return n
    if DP[k][n] > 0:
        return DP[k][n]
    res = n
    for i = 1 to n:
        max_res = max(count(k-1,i-1),count(k,n-1))+1
        res = min(res,max_res)
    return DP[k][n] = res
```
经过这番操作之后，中间很多无用的过程就被略过了，大大提高了效率。  
